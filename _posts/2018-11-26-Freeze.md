---
layout: post
title: ! 'RITSEC_CTF_FreeZe'
excerpt_separator: <!--more-->
tags:
  - Koon
  - Write-up
  - RITSEC CTF
  - binwalk
  - pyi-archive-viewer
---

RITSEC CTF 2018에 나온 리버싱 문제 Freeze에 관하여 작성합니다.

<!--more-->

## 개요

RITSEC CTF 기간에 1~2시간 동안 문제를 분석해보았지만, 별 다른 접근법이 생각이 나지 않아 포기하였다.

외국 애들이 쓴 Write-up이 올라오자 마자 직접 확인해보며, 공부 하였다.

핵심은 결국 어떤 실행 파일인가? 와 어떤 디컴파일러 도구를 사용해야 하는가? 였다.

## 도구
이 문제를 푸는데에는 총 2가지 도구를 활용한다.

2개 중 1개는 사실 별 필요 없는 도구이지만, 다른 CTF Write up에서도 간간히 쓰이는 것이 보여, 같이 사용하였다.

아래 한줄 글은... 그냥 내가 그렇게 느낀거임

* binwalk = 바이너리, 펌웨어 추출 및 분석 툴
* pyi-archive_viewer = 파이썬으로 만들어진 파일의 디컴파일러 및 분석 도구



## 풀기
대회 기간 당시, 문제 페이지에 들어가면 아래 사진과 같다.

![]({{ site.baseurl }}/images/Koon/Freeze/Freeze_1.PNG)
두개의 파일을 준다. (main과 libpython~)

![]({{ site.baseurl }}/images/Koon/Freeze/Freeze_2.PNG)
두개의 파일을 같은 공간에 두고, 실행을 시키면 숫자가 나온다.


![]({{ site.baseurl }}/images/Koon/HateIntel/hate_3.PNG)
print, scanf, strlen 등의 함수들이 쓰였고, 그 인자들은 r0,r1,r2 의 레지스터들에 의해 받아서 실행되어 진다.

여기서 arm의 어셈을 보면서, 혼란스러웠던 것이 파란색 부분이다.

scanf로 예를 들어보면, "sp,0x60 + var ??" 였던 부분이 scanf 함수에 의해 키보드로 입력한 값들이 저장 되는 부분이라고 할 수 있다.

0x60 + var?? 부분이 사실 주소를 어떻게 표현하고 있는건지 잘 이해가 가지 않았다. 

여러 예제를 찾아보다가, 0x60이 변수들을 위해 sub로 공간을 할당하는 크기라는 것을 알았고, var ?? 등은 그 안에서 각각 자리 잡는 변수들이라는 것을 알게 되었다.

결국 0x60은 변수들의 base 주소라고 생각하면 되고,  var 부분을 IDA의 Rename을 통해 해당 역할을 이름으로 바꿔서 흐름을 분석하고 있다.

input값이 받아지는 곳은 input으로, 길이를 나타내는 것은 Length로, 비교 카운트의 역할을 하는 것은 Count num 으로 지정하여 하고 있다.



![]({{ site.baseurl }}/images/Koon/HateIntel/hate_4.PNG)
sub232c 함수가 실행되었고, 파란색 영역으로 진입하게 된다.

파란색 영역에는 byte3004라는 비교하기 위한 배열이 존재한다. 이 배열에는 각각의 값들이 채워져있다. 즉 input값으로 넣어진 값들과 이 배열들이 index 0부터 시작하여 하나씩 비교 되어진다.

비교하는 역할이 파란색 영역이고, loc22d4부분이 index가 하나씩 늘어나는 과정을 표현한 것이다.

그러면, input값이 어떻게 변해서 byte3004 배열이 되는지 확인하면 된다.

이 사이에는 하나의 함수가 실행된 것 뿐인데, 그 함수는 sub232c이므로, 이 sub232c를 분석하면 된다.


![]({{ site.baseurl }}/images/Koon/HateIntel/hate_5.PNG)
sub232c를 보면, 무슨 여러가지 하다가? sub249c로 넘어가게 된다.
이부분은 어셈으로 보기 좀 빡세서(아직은)...  코드로 보았다.(확실히 편하다.)

결국 sub232c-sub249c에서 입력 값에 변화를 준다는 것을 확인을 하였다.

이 변화가 무엇이다!. 라고 확정지으면, 그렇게 해서 코드를 짜서 정답을 알아내도 되지만... 브루트 포스 형식으로 여러 값을 집어넣어, 정답을 알아내도 된다.

그 이유는 sub232c-sub249c 모두 코드로 나타낼수 잇기 때문에 직접 c 코드로 구현하여, byte3004 배열이 되도록 만드는 값을 찾으면 된다.

#코드
![]({{ site.baseurl }}/images/Koon/HateIntel/hate_6.PNG)
코드 부분!(설명 안함)

## 결론
ARM이 아직 익숙치 않다.

좀 더 해야겟다!
