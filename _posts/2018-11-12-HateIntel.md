---
layout: post
title: ! 'ARM_REVERSING_01_HateIntel'
excerpt_separator: <!--more-->
tags:
  - Koon
  - Write-up
  - Reversing.kr
  - ARM
---

요즘 안드로이드 기기에 대해서, 여러가지 작업을 수행 중인데... 바이너리를 추출하여 보면 임베디드 기기 특성 상 ARM으로 되어 있기에... ARM에 대한 공부의 필요성을 느꼇다.

<!--more-->

## 개요

ARM 레지스터 구성, 명령어 종류, 함수 호출 규약 같은 기본적인 지식은 알고 있었지만... 실제 분석에서 이러한 지식을 사용하는데에 있어... 

익숙치 않기 때문에 ARM 바이너리 문제를 통해 익숙해지는 것이 좋다고 생각했다.

CTF 문제 중에 찾으려 했지만... 마땅한 것을 아직 찾지 못하여, REVERSING.KR에 있는 HateIntel이 ARM 바이너리로 되어 있다고 하여... 이것으로 선택했습니다.

## 문제 상황
ARM 바이너리의 경우, 그에 맞는 환경을 구성해주어야 하는데... 아직 구성은 안해주어... 실행하는 것은 아직 불가능

다만 짱짱 도구인 IDA로 볼 수 있기에... 이 IDA를 통한 정적 분석을 통해 문제를 해결

## 풀기
HateIntel 파일을 IDA로 실행하면... sub 함수 자체가 별루 없어... 분석하기 쉬워보인다.

IDA로 보면... 솔직히 어셈 그 자체를 보는 것이 아닌, 코드로 변경해서 보여주는 기능이 있어... ARM 공부에 도움이 안되기 때문에... 분석에서는 어셈을 통해서 흐름을 익혔다.
(어셈으로 흐름을 예상하고, 코드로 그 흐름이 맞는지 확인하는 정도?)


![]({{ site.baseurl }}/images/Koon/HateIntel/hate_1.PNG)
String view를 통해 찾아보면, Correct와 Wrong을 나누는 것을 볼 수 있기 때문에, 이 부분의 주소를 분석하면 될 것이라는 느낌이 온다.

![]({{ site.baseurl }}/images/Koon/HateIntel/hate_2.PNG)
위의 그림을 보면... 초록색은 "right" 빨간색은 "wrong"이며, 파란색은 이 두개의 흐름을 결정해주는 역할을 하는 곳이다.

##상세 분석
![]({{ site.baseurl }}/images/Koon/HateIntel/hate_3.PNG)
print, scanf, strlen 등의 함수들이 쓰였고, 그 인자들은 r0,r1,r2 의 레지스터들에 의해 받아서 실행되어 진다.

여기서 arm의 어셈을 보면서, 혼란스러웠던 것이 파란색 부분이다.

scanf로 예를 들어보면, "sp,0x60 + var ??" 였던 부분이 scanf 함수에 의해 키보드로 입력한 값들이 저장 되는 부분이라고 할 수 있다.

0x60 + var?? 부분이 사실 주소를 어떻게 표현하고 있는건지 잘 이해가 가지 않았다. 

여러 예제를 찾아보다가, 0x60이 변수들을 위해 sub로 공간을 할당하는 크기라는 것을 알았고, var ?? 등은 그 안에서 각각 자리 잡는 변수들이라는 것을 알게 되었다.

결국 0x60은 변수들의 base 주소라고 생각하면 되고,  var 부분을 IDA의 Rename을 통해 해당 역할을 이름으로 바꿔서 흐름을 분석하고 있다.

input값이 받아지는 곳은 input으로, 길이를 나타내는 것은 Length로, 비교 카운트의 역할을 하는 것은 Count num 으로 지정하여 하고 있다.



![]({{ site.baseurl }}/images/Koon/HateIntel/hate_4.PNG)
sub232c 함수가 실행되었고, 파란색 영역으로 진입하게 된다.

파란색 영역에는 byte3004라는 비교하기 위한 배열이 존재한다. 이 배열에는 각각의 값들이 채워져있다. 즉 input값으로 넣어진 값들과 이 배열들이 index 0부터 시작하여 하나씩 비교 되어진다.

비교하는 역할이 파란색 영역이고, loc22d4부분이 index가 하나씩 늘어나는 과정을 표현한 것이다.

그러면, input값이 어떻게 변해서 byte3004 배열이 되는지 확인하면 된다.

이 사이에는 하나의 함수가 실행된 것 뿐인데, 그 함수는 sub232c이므로, 이 sub232c를 분석하면 된다.


![]({{ site.baseurl }}/images/Koon/HateIntel/hate_5.PNG)
sub232c를 보면, 무슨 여러가지 하다가? sub249c로 넘어가게 된다.
이부분은 어셈으로 보기 좀 빡세서(아직은)...  코드로 보았다.(확실히 편하다.)

결국 sub232c-sub249c에서 입력 값에 변화를 준다는 것을 확인을 하였다.

이 변화가 무엇이다!. 라고 확정지으면, 그렇게 해서 코드를 짜서 정답을 알아내도 되지만... 브루트 포스 형식으로 여러 값을 집어넣어, 정답을 알아내도 된다.

그 이유는 sub232c-sub249c 모두 코드로 나타낼수 잇기 때문에 직접 c 코드로 구현하여, byte3004 배열이 되도록 만드는 값을 찾으면 된다.

#코드
![]({{ site.baseurl }}/images/Koon/HateIntel/hate_6.PNG)
코드 부분!(설명 안함)

## 결론
ARM이 아직 익숙치 않다.

좀 더 해야겟다!
