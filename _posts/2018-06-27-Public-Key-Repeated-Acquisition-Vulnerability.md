---
layout: post
title: "[Crypto] RSA 반복 공개키 획득 취약점"
excerpt_separator: <!--more-->
tags:
- Crypto
- RSA
- dajababa09
---

현재 모든 공개키암호의 공개키는 '0x10001' 로 고정되어있다.
1024비트의 큰 소수 2개를 사용하여 더 크고 다양한 공개키를 사용 할 수 있지만 사용하지 않는 이유로 몇가지가 있지만 가장 중요한 이유로 반복 공개키 획득 취약점이 있다.

<!--more-->
## 1. 반복 공개키 획득 취약점이란?
반복 공개키 획득 취약점이란 일정한 조건을 만족하는 공개키와 그 공개키로 같은 평문을 암호화한 암호문을 알 수 있다면 개인키를 알 필요 없이 평문이 복원 가능한 것을 의미한다.

예시를 들어보자

공개키를 0x10001로 고정하지 않고키를 생성하여  암호화를 하는 로그인 페이지가 있다고 하고 사용자는 이 페이지에서 여러번 로그인을 하였고 공격자는 그 때의 공개키와 암호문을 획득하였다.

이때 공개키의 경우는 다음과 같다.

#### 1. n<sub>1</sub>과 n<sub>2</sub>가 다른 경우
n<sub>1</sub>과 n<sub>2</sub> 가다르면 전혀 문제가 되지 않는다. n끼리의 연관성이 없기 때문에 n이 하나가 있던 2개 이상이 있던 아무런 이득이 없다.

#### 2. n<sub>1</sub>과 n<sub>2</sub>가 같고 공개키 e<sub>1</sub>과 e<sub>2</sub>가 서로 다른 경우
문제는 여기서 나온다. 만약 n<sub>1</sub>과 n<sub>2</sub>가 서로 같고 e<sub>1</sub>과 e<sub>2</sub>가 서로 다르며 서로소라면 개인키를 알지 않아도 아래와 같은 이유로  평문을 찾을 수 있다.
 
n<sub>1</sub> = n<sub>2</sub> = n  

c<sub>1</sub> = m<sup>e<sub>1</sub></sup> mod n  

c<sub>2</sub> = m<sup>e<sub>2</sub></sup> mod n  

일때, 
e<sub>1</sub>과 e<sub>2</sub>가 서로수 이므로 e<sub>1</sub>x + e<sub>2</sub>y = 1을 만족하는 x, y가 존재 한다.
그러므로

c<sub>1</sub><sup>x</sup> * c<sub>2</sub><sup>y</sup> = m<sup>e<sub>1</sub>x</sup> * m<sup>e<sub>2</sub>y</sup> = m<sup>e<sub>1</sub>x + e<sub>2</sub>y</sup> = m<sup>1</sup>이 되므로 평문인m을 복구할 수 있다.


## 2. 검증
sage를 사용하여 예시를 들어보자

처음 다음과 같이 셋팅을 한다.

![]({{ site.baseurl}}/images/dajababa/[18_06_27]pubKey/settind_dajaba.png)

그 다음 각각의 공개키 를 사용하여 암호문을 얻는다.

chipher1
![]({{ site.baseurl}}/images/dajababa/[18_06_27]pubKey/cipher1_dajaba.png)

chipher2
![]({{ site.baseurl}}/images/dajababa/[18_06_27]pubKey/cipher2_dajaba.png)

그 다음 유클리드 호제법을 사용하여 e<sub>1</sub>x + e<sub>2</sub>y = 1를 만족하는 x와 y를 찾는다.

![]({{ site.baseurl}}/images/dajababa/[18_06_27]pubKey/findXY_dajaba.png)

마지막으로 위에서 찾은 x, y를 사용하여 연산을 하면 평문이 나오는 것을 확인 할 수 있다.
![]({{ site.baseurl}}/images/dajababa/[18_06_27]pubKey/findM_dajaba.png)

이상 글을 마치겠다.
